/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. projet.jj */
/*@egen*/options{           }
/** Je test la modif **/
PARSER_BEGIN(Projet)

import java.io.*;

public class Projet/*@bgen(jjtree)*/implements ProjetTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected static JJTProjetState jjtree = new JJTProjetState();

/*@egen*/
	public static void main(String[] args) throws Exception {
		System.out.println(args[0]);
		System.out.println("Debut parsing du code C");
		Projet parser = new Projet(new FileReader(new File(args[0])));
		parser.Axiome ();
		
		System.out.println("Parsing = OK.");
		Node racine = parser.jjtree.rootNode();
		((SimpleNode)racine).dump(">");
	}
}

PARSER_END(Projet)


/** Tokens skip **/
SKIP : { 
	" " | "\r" | "\t" | "\n"
}


/** Tokens reserved **/
TOKEN : {
	

 	  < IF: "if" > 
	| < FOR : "for" >
  	| < THEN: "then" >
  	| < ELSE: "else">
  	| < DO: "do" >
  	| < WHILE: "while" >
  	| < BREAK: "break" >
  	| < SWITCH: "switch" >
  	| < CASE: "case" >
  	| < RETURN: "return" >


	| < INT: "int" >
	| < CHAR: "char" >
	| < FLOAT: "float" >
  	
  	
	| < PARAL: "(" > 
  	| < PARAR: ")" >
  	
	| < ACCOL: "{" > 
  	| < ACCOR: "}" >
  	
  	| < BL: "<" >
	| < BR: ">" >
  	
	| < EGAL: "=" > 
  	| < PVIRG: ";" >
	| < POINT: "." >
	| < NOT : "!" >
	| < VIRG: "," >
	| < DPOINT: ":" >
	
	| < TRUE: "true" >
	| < FALSE: "false" >
	
	| < INCR: "++" >
	| < DECR: "--" >
	
	| < PLUS: "+" >
	| < MINUS: "-" >
	| < MULT: "*" >
	| < DIV: "/" >
	| < MOD: "%" >
	
	| <AND: "&" >
	| <OR: "|" >

	| < SHARP: "#" >	
	| < INCLUDE: "include" >
	| < EXTENSI: ".h" >
	
	| < STRUCT: "struct" >
	| < ENUM: "enum" >
	 
}



/** Tokens literaux */

TOKEN : {
	  < INTEGER: (["0"-"9"])+ >
	| < IDENT: (["a"-"z"] | ["A"-"Z"]) (["a"-"z"] | ["A"-"Z"] | ["0"-"9"] | "_")* >
}


/** Syntaxique rules **/
void Axiome()      : {} {
	  Code()
	//AffichageLexeme()
}


/** Shows Lex\u00e8mes **/
void AffichageLexeme() : {/*@bgen(jjtree) AffichageLexeme */
  ASTAffichageLexeme jjtn000 = new ASTAffichageLexeme(JJTAFFICHAGELEXEME);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) AffichageLexeme */
        try {
/*@egen*/
	(
		( < IF> {System.out.print("Token IF = ");}
		| < THEN> {System.out.print("Token THEN = ");}
		| < PARAL> {System.out.print("Token PARAL = ");}
		| < PARAR> {System.out.print("Token PARAR = ");}
		| < ACCOL> {System.out.print("Token ACCOL = ");}
		| < ACCOR> {System.out.print("Token ACCOR = ");}
		| < EGAL> {System.out.print("Token EGAL = ");}
		| < PVIRG> {System.out.print("Token PVIRG = ");}
		| < ELSE> {System.out.print("Token ELSE = ");}
		| <FOR> {System.out.print("Token FOR = ");}
		| <PLUS> {System.out.print("Token PLUS = ");}
		| <MINUS> {System.out.print("Token MINUS = ");}
		| <MULT> {System.out.print("Token MULT = ");}
		| <DIV> {System.out.print("Token DIV = ");}
		| <IDENT> {System.out.print("Token IDENT = ");}
		| <INTEGER> {System.out.print("Token INTEGER = ");}
		) {System.out.println(token.image);}
	)+ 
	<EOF>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


/** Syntaxique code rules **/

void Code() : {/*@bgen(jjtree) Code */
  ASTCode jjtn000 = new ASTCode(JJTCODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Code */
        try {
/*@egen*/
	Instructions()
	<EOF>/*@bgen(jjtree)*/
              {
                jjtree.closeNodeScope(jjtn000, true);
                jjtc000 = false;
              }
/*@egen*/ {System.out.println("Fin fichier.");}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


void Instructions()      : {} {
	(  	 
		  Comment()
		| Include()
		| Function()
	)+	
}

void Operator() : {/*@bgen(jjtree) Operator */
  ASTOperator jjtn000 = new ASTOperator(JJTOPERATOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Operator */
        try {
/*@egen*/
	<PLUS> | <MINUS> | <DIV> | <MULT>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void LogicalOperator() : {/*@bgen(jjtree) LogicalOperator */
  ASTLogicalOperator jjtn000 = new ASTLogicalOperator(JJTLOGICALOPERATOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) LogicalOperator */
        try {
/*@egen*/
	<AND> | <OR>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/ // Voir pour ajouter && || avec le LOOKAHEAD pour retirer les r\u00e9cusrivit\u00e9es a gauche
}


void Include()         : {/*@bgen(jjtree) Include */
  ASTInclude jjtn000 = new ASTInclude(JJTINCLUDE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Include */
                try {
/*@egen*/
		<SHARP><INCLUDE> <BL> Ident() (<EXTENSI>)? <BR>/*@bgen(jjtree)*/
                } catch (Throwable jjte000) {
                  if (jjtc000) {
                    jjtree.clearNodeScope(jjtn000);
                    jjtc000 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte000 instanceof RuntimeException) {
                    throw (RuntimeException)jjte000;
                  }
                  if (jjte000 instanceof ParseException) {
                    throw (ParseException)jjte000;
                  }
                  throw (Error)jjte000;
                } finally {
                  if (jjtc000) {
                    jjtree.closeNodeScope(jjtn000, true);
                  }
                }
/*@egen*/
}	


void Comment()             : {/*@bgen(jjtree) Commentaire */
  ASTCommentaire jjtn000 = new ASTCommentaire(JJTCOMMENTAIRE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Commentaire */
                try {
/*@egen*/
		<DIV><MULT> (LOOKAHEAD(Ident()) Ident())+ <MULT><DIV>/*@bgen(jjtree)*/
                } catch (Throwable jjte000) {
                  if (jjtc000) {
                    jjtree.clearNodeScope(jjtn000);
                    jjtc000 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte000 instanceof RuntimeException) {
                    throw (RuntimeException)jjte000;
                  }
                  if (jjte000 instanceof ParseException) {
                    throw (ParseException)jjte000;
                  }
                  throw (Error)jjte000;
                } finally {
                  if (jjtc000) {
                    jjtree.closeNodeScope(jjtn000, true);
                  }
                }
/*@egen*/
}

void Type()      : {/*@bgen(jjtree) Type */
                    ASTType jjtn000 = new ASTType(JJTTYPE);
                    boolean jjtc000 = true;
                    jjtree.openNodeScope(jjtn000);
/*@egen*/String val = "";} {/*@bgen(jjtree) Type */
                try {
/*@egen*/ 
		(<INT> | <CHAR> | <FLOAT>)/*@bgen(jjtree)*/
                                           {
                                             jjtree.closeNodeScope(jjtn000, true);
                                             jjtc000 = false;
                                           }
/*@egen*/ {
									try {
										val = token.image;
									} catch (Exception e) {
										System.err.println("Not a type : " + token.image);
									}
										jjtn000.setValeur(val);
									}/*@bgen(jjtree)*/
                } finally {
                  if (jjtc000) {
                    jjtree.closeNodeScope(jjtn000, true);
                  }
                }
/*@egen*/
}

void Body()      : {} { // Revoir car warning LOOKAHEAD
  	(  
	  Comment()
	| Affectation()
	| Boucles()
	| Condition()
  )*
}

void Function()          : {/*@bgen(jjtree) Function */
  ASTFunction jjtn000 = new ASTFunction(JJTFUNCTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Function */
        try {
/*@egen*/
	Type() Ident() <PARAL> Parameters() <PARAR> <ACCOL> Body() <ACCOR>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Parameters() : {/*@bgen(jjtree) Parameters */
  ASTParameters jjtn000 = new ASTParameters(JJTPARAMETERS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Parameters */
                                try {
/*@egen*/ // Erreur pour plusieurs param\u00e8tres
				(LOOKAHEAD(3)	  (Type() Ident() <VIRG>)
							    | (Type() Ident() ))*/*@bgen(jjtree)*/
                                } catch (Throwable jjte000) {
                                  if (jjtc000) {
                                    jjtree.clearNodeScope(jjtn000);
                                    jjtc000 = false;
                                  } else {
                                    jjtree.popNode();
                                  }
                                  if (jjte000 instanceof RuntimeException) {
                                    throw (RuntimeException)jjte000;
                                  }
                                  if (jjte000 instanceof ParseException) {
                                    throw (ParseException)jjte000;
                                  }
                                  throw (Error)jjte000;
                                } finally {
                                  if (jjtc000) {
                                    jjtree.closeNodeScope(jjtn000, true);
                                  }
                                }
/*@egen*/	
}

void ConditionSigne() : {/*@bgen(jjtree) ConditionSigne */
  ASTConditionSigne jjtn000 = new ASTConditionSigne(JJTCONDITIONSIGNE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) ConditionSigne */
                try {
/*@egen*/ // Permet de lever l'ind\u00e9cision a revoir pour pouvoir en mettre plus
		LOOKAHEAD(4)  <BL><EGAL>   // <= 
					| <BR><EGAL>   // >=
					| <EGAL><EGAL> // ==
					| <NOT><EGAL>/*@bgen(jjtree)*/
                } finally {
                  if (jjtc000) {
                    jjtree.closeNodeScope(jjtn000, true);
                  }
                }
/*@egen*/  // !=
					/*| <BL>
					| <BR>*/
}


void CorpsCondition()           : {/*@bgen(jjtree) #corpCC( 2) */
  ASTcorpCC jjtn000 = new ASTcorpCC(JJTCORPCC);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) #corpCC( 2) */
        try {
/*@egen*/ // a revoir pour ajouter LogicalOperator()
	Ident() ConditionSigne() (Ident() | (<INTEGER>)*)/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000,  2);
          }
        }
/*@egen*/ 	
}

void Condition() : {/*@bgen(jjtree) Condition */
  ASTCondition jjtn000 = new ASTCondition(JJTCONDITION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Condition */
        try {
/*@egen*/
	<IF> <PARAL> CorpsCondition() <PARAR> <ACCOL> Body() <ACCOR> [ <ELSE>  <ACCOL> Body() <ACCOR>]/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Affectation()             : {/*@bgen(jjtree) Affectation */
  ASTAffectation jjtn000 = new ASTAffectation(JJTAFFECTATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Affectation */
        try {
/*@egen*/
	((Type() Ident()) | Ident()) <EGAL> (<INTEGER>)+ <PVIRG>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Boucles() : {/*@bgen(jjtree) Boucles */
  ASTBoucles jjtn000 = new ASTBoucles(JJTBOUCLES);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Boucles */
              try {
/*@egen*/
	      For() 
		| While()
		| DoWhile()
		| Switch()/*@bgen(jjtree)*/
              } catch (Throwable jjte000) {
                if (jjtc000) {
                  jjtree.clearNodeScope(jjtn000);
                  jjtc000 = false;
                } else {
                  jjtree.popNode();
                }
                if (jjte000 instanceof RuntimeException) {
                  throw (RuntimeException)jjte000;
                }
                if (jjte000 instanceof ParseException) {
                  throw (ParseException)jjte000;
                }
                throw (Error)jjte000;
              } finally {
                if (jjtc000) {
                  jjtree.closeNodeScope(jjtn000, true);
                }
              }
/*@egen*/
}


void DIncrementation() : {/*@bgen(jjtree) DIncrementation */
  ASTDIncrementation jjtn000 = new ASTDIncrementation(JJTDINCREMENTATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) DIncrementation */
        try {
/*@egen*/
	Ident() (<INCR> | <DECR>)/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


void For() : {/*@bgen(jjtree) For */
  ASTFor jjtn000 = new ASTFor(JJTFOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) For */
        try {
/*@egen*/
	<FOR> <PARAL> Affectation() Ident() ConditionSigne() (Ident() | (<INTEGER>)+) <PVIRG> DIncrementation() <PARAR> <ACCOL> Body() <ACCOR>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/ 	
}

void While() : {/*@bgen(jjtree) While */
  ASTWhile jjtn000 = new ASTWhile(JJTWHILE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) While */
        try {
/*@egen*/ // Probleme avec le while je comprend pas trop pk 
	<WHILE> <PARAL> CorpsCondition() <PARAR> <ACCOL> Body() Ident() (<INCR> | <DECR>) <ACCOR>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void DoWhile() : {/*@bgen(jjtree) DoWhile */
  ASTDoWhile jjtn000 = new ASTDoWhile(JJTDOWHILE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) DoWhile */
        try {
/*@egen*/
	<DO> <ACCOL> Body() <ACCOR> <WHILE> <PARAL> CorpsCondition() <PARAR>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Switch() : {/*@bgen(jjtree) Switch */
  ASTSwitch jjtn000 = new ASTSwitch(JJTSWITCH);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Switch */
        try {
/*@egen*/
	<SWITCH> <PARAL> Ident() <PARAR> <ACCOL> (<CASE> Ident() <DPOINT> Body() <BREAK> <PVIRG>)+ <ACCOR>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


/** Expressions Arithmetiques */

void ExpressionArithmetique() : {/*@bgen(jjtree) ExpressionArithmetique */
  ASTExpressionArithmetique jjtn000 = new ASTExpressionArithmetique(JJTEXPRESSIONARITHMETIQUE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) ExpressionArithmetique */
        try {
/*@egen*/
	ProduitArithmetique() (   ( <PLUS> ExpressionArithmetique())
				| ( <MINUS> ExpressionArithmetique() ) )?/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void ProduitArithmetique() : {/*@bgen(jjtree) ProduitArithmetique */
  ASTProduitArithmetique jjtn000 = new ASTProduitArithmetique(JJTPRODUITARITHMETIQUE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) ProduitArithmetique */
        try {
/*@egen*/
	Element() (   ( <MULT> ProduitArithmetique() ) 
		    | ( <DIV> ProduitArithmetique()  ))?/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Element()       : {} {
	 Entier() | <IDENT> 
}

void Entier() : {/*@bgen(jjtree) Entier */
  ASTEntier jjtn000 = new ASTEntier(JJTENTIER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  int val1 = 1;
  int val = 0;
} {/*@bgen(jjtree) Entier */
  try {
/*@egen*/
  (<MINUS> { })?
  <INTEGER>/*@bgen(jjtree)*/
            {
              jjtree.closeNodeScope(jjtn000, true);
              jjtc000 = false;
            }
/*@egen*/ {   }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

/** Expressions Booleennes */
void ExpressionBooleenne() : {/*@bgen(jjtree) ExpressionBooleenne */
  ASTExpressionBooleenne jjtn000 = new ASTExpressionBooleenne(JJTEXPRESSIONBOOLEENNE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) ExpressionBooleenne */
         try {
/*@egen*/
	 Element() ( <EGAL><EGAL> (<TRUE>|<FALSE>) )? | <NOT>Element()/*@bgen(jjtree)*/
         } catch (Throwable jjte000) {
           if (jjtc000) {
             jjtree.clearNodeScope(jjtn000);
             jjtc000 = false;
           } else {
             jjtree.popNode();
           }
           if (jjte000 instanceof RuntimeException) {
             throw (RuntimeException)jjte000;
           }
           if (jjte000 instanceof ParseException) {
             throw (ParseException)jjte000;
           }
           throw (Error)jjte000;
         } finally {
           if (jjtc000) {
             jjtree.closeNodeScope(jjtn000, true);
           }
         }
/*@egen*/
}


void Ident() : {/*@bgen(jjtree) Ident */
                ASTIdent jjtn000 = new ASTIdent(JJTIDENT);
                boolean jjtc000 = true;
                jjtree.openNodeScope(jjtn000);
/*@egen*/String val = "";} {/*@bgen(jjtree) Ident */
        try {
/*@egen*/
	<IDENT>/*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                }
/*@egen*/ {
	try {
		val = token.image;
	} catch (Exception e) {
		System.err.println("Not a string : " + token.image);
	}
		jjtn000.setValeur(val);
	}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/*
void Integer() : {Int val = 0;} {
	<INTEGER> {
	try {
		val = token.image;
	} catch (Exception e) {
		System.err.println("Not a number : " + token.image);
	}
		jjtThis.setValeur(val);
	}
}*/
