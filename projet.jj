/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. projet.jj */
/*@egen*/options{           }
/** Je test la modif **/
PARSER_BEGIN(Projet)

import java.io.*;

public class Projet/*@bgen(jjtree)*/implements ProjetTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected static JJTProjetState jjtree = new JJTProjetState();

/*@egen*/
	public static void main(String[] args) throws Exception {
		System.out.println(args[0]);
		System.out.println("Debut parsing du code C");
		Projet parser = new Projet(new FileReader(new File(args[0])));
		parser.Axiome ();
		
		System.out.println("Parsing = OK.");
		Node racine = parser.jjtree.rootNode();
		((SimpleNode)racine).dump(">");
	}
}

PARSER_END(Projet)


/** Tokens skip **/
SKIP : { 
	" " | "\r" | "\t" | "\n"
}


/** Tokens reserved **/
TOKEN : {
	 < MAIN : "main" >

 	| < IF: "if" > 
	| < FOR : "for" >
  	| < THEN: "then" >
  	| < ELSE: "else">

	| < INT : "int" >
	| < CHAR : "char" >
	| < FLOAT : "float" >
	| < LONG : "long" >
  	
	| < PARAL: "(" > 
  	| < PARAR: ")" >
  	
	| < ACCOL: "{" > 
  	| < ACCOR: "}" >
  	
	| < EGAL: "=" > 
  	| < PVIRG: ";" >
	| < POINT: "." >
	| < NOT : "!" >
	
	| < TRUE: "true" >
	| < FALSE: "false" >
	
	
	| < PLUS: "+" >
	| < MINUS: "-" >
	| < MULT: "*" >
	| < DIV: "/" >
}



/** Tokens literaux */

TOKEN : {
	  < INTEGER: (["0"-"9"])+ >
	| < IDENT: (["a"-"z"] | ["A"-"Z"]) (["a"-"z"] | ["A"-"Z"] | ["0"-"9"] | "_")* >
}


/** Syntaxique rules **/
void Axiome()      : {} {
	  Code()
	//AffichageLexeme()
}


/** Shows Lex\u00e8mes **/
void AffichageLexeme() : {/*@bgen(jjtree) AffichageLexeme */
  ASTAffichageLexeme jjtn000 = new ASTAffichageLexeme(JJTAFFICHAGELEXEME);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) AffichageLexeme */
        try {
/*@egen*/
	(
		( < IF> {System.out.print("Token IF = ");}
		| < THEN> {System.out.print("Token THEN = ");}
		| < PARAL> {System.out.print("Token PARAL = ");}
		| < PARAR> {System.out.print("Token PARAR = ");}
		| < ACCOL> {System.out.print("Token ACCOL = ");}
		| < ACCOR> {System.out.print("Token ACCOR = ");}
		| < EGAL> {System.out.print("Token EGAL = ");}
		| < PVIRG> {System.out.print("Token PVIRG = ");}
		| < ELSE> {System.out.print("Token ELSE = ");}
		| <FOR> {System.out.print("Token FOR = ");}
		| <PLUS> {System.out.print("Token PLUS = ");}
		| <MINUS> {System.out.print("Token MINUS = ");}
		| <MULT> {System.out.print("Token MULT = ");}
		| <DIV> {System.out.print("Token DIV = ");}
		| <IDENT> {System.out.print("Token IDENT = ");}
		| <INTEGER> {System.out.print("Token INTEGER = ");}
		| <MAIN> {System.out.println("Token MAIN = ");}
		) {System.out.println(token.image);}
	)+ 
	<EOF>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


/** Syntaxique code rules **/

void Code() : {/*@bgen(jjtree) Code */
  ASTCode jjtn000 = new ASTCode(JJTCODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Code */
        try {
/*@egen*/
	Instructions()
	<EOF>/*@bgen(jjtree)*/
              {
                jjtree.closeNodeScope(jjtn000, true);
                jjtc000 = false;
              }
/*@egen*/ {System.out.println("Fin fichier.");}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


void Instructions()      : {} {
	(  	 Main()
		| Condition() 
		| Affectation()
		| For()
		
	)+	
}

void Main()      : {/*@bgen(jjtree) Main */
  ASTMain jjtn000 = new ASTMain(JJTMAIN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Main */
        try {
/*@egen*/
	<MAIN> <PARAL> <PARAR> <ACCOR> <ACCOL>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/	
}

void Condition() : {/*@bgen(jjtree) Condition */
  ASTCondition jjtn000 = new ASTCondition(JJTCONDITION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Condition */
        try {
/*@egen*/
	<IF> <PARAL> Ident() <PARAR> <THEN> <ACCOL> Instructions() <ACCOR> [ <ELSE>  <ACCOL> Instructions() <ACCOR>]/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Affectation()             : {/*@bgen(jjtree) Affectation */
  ASTAffectation jjtn000 = new ASTAffectation(JJTAFFECTATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Affectation */
        try {
/*@egen*/
	Ident() <EGAL> ExpressionArithmetique() <PVIRG>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void For() : {/*@bgen(jjtree) For */
  ASTFor jjtn000 = new ASTFor(JJTFOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) For */
        try {
/*@egen*/
	<FOR> <PARAL> Ident() <EGAL> ExpressionArithmetique() <PVIRG> Ident() <PVIRG> Ident() <PARAR> <ACCOL> Instructions() <ACCOR>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/ 
	
}


/** Expressions Arithmetiques */

void ExpressionArithmetique() : {/*@bgen(jjtree) ExpressionArithmetique */
  ASTExpressionArithmetique jjtn000 = new ASTExpressionArithmetique(JJTEXPRESSIONARITHMETIQUE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) ExpressionArithmetique */
        try {
/*@egen*/
	ProduitArithmetique() (   ( <PLUS> ExpressionArithmetique())
				| ( <MINUS> ExpressionArithmetique() ) )?/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/

}

void ProduitArithmetique() : {/*@bgen(jjtree) ProduitArithmetique */
  ASTProduitArithmetique jjtn000 = new ASTProduitArithmetique(JJTPRODUITARITHMETIQUE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) ProduitArithmetique */
        try {
/*@egen*/
	Element() (   ( <MULT> ProduitArithmetique() ) 
		    | ( <DIV> ProduitArithmetique()  ))?/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Element()       : {} {
	 Entier() | <IDENT> 
}

void Entier() : {/*@bgen(jjtree) Entier */
  ASTEntier jjtn000 = new ASTEntier(JJTENTIER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  int val1 = 1;
  int val = 0;
} {/*@bgen(jjtree) Entier */
  try {
/*@egen*/
  (<MINUS> { })?
  <INTEGER>/*@bgen(jjtree)*/
            {
              jjtree.closeNodeScope(jjtn000, true);
              jjtc000 = false;
            }
/*@egen*/ {   }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

/** Expressions Booleennes */

void ExpressionBooleenne() : {/*@bgen(jjtree) ExpressionBooleenne */
  ASTExpressionBooleenne jjtn000 = new ASTExpressionBooleenne(JJTEXPRESSIONBOOLEENNE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) ExpressionBooleenne */
         try {
/*@egen*/
	 Element() ( <EGAL><EGAL> (<TRUE>|<FALSE>) )? | <NOT>Element()/*@bgen(jjtree)*/
         } catch (Throwable jjte000) {
           if (jjtc000) {
             jjtree.clearNodeScope(jjtn000);
             jjtc000 = false;
           } else {
             jjtree.popNode();
           }
           if (jjte000 instanceof RuntimeException) {
             throw (RuntimeException)jjte000;
           }
           if (jjte000 instanceof ParseException) {
             throw (ParseException)jjte000;
           }
           throw (Error)jjte000;
         } finally {
           if (jjtc000) {
             jjtree.closeNodeScope(jjtn000, true);
           }
         }
/*@egen*/
}


void Ident()  : {/*@bgen(jjtree) Ident */
        ASTIdent jjtn000 = new ASTIdent(JJTIDENT);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	String val = "";
	} {/*@bgen(jjtree) Ident */
        try {
/*@egen*/
	<IDENT>/*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                }
/*@egen*/ {
	try {
		val = token.image;
	} catch (Exception e) {
		System.err.println("Not a string : " + token.image);
	}
	//jjtThis.setValeur(val);
	}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}
