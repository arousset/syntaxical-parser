options{multi=true;}
/** Je test la modif **/
PARSER_BEGIN(Projet)

import java.io.*;

public class Projet {
	public static void main(String[] args) throws Exception {
		System.out.println(args[0]);
		System.out.println("Debut parsing du code C");
		Projet parser = new Projet(new FileReader(new File(args[0])));
		parser.Axiome ();
		
		System.out.println("Parsing = OK.");
		Node racine = parser.jjtree.rootNode();
		((SimpleNode)racine).dump(">");
	}
}

PARSER_END(Projet)


/** Tokens skip **/
SKIP : { 
	" " | "\r" | "\t" | "\n"
}


/** Tokens reserved **/
TOKEN : {
	 < MAIN : "main" >

 	| < IF: "if" > 
	| < FOR : "for" >
  	| < THEN: "then" >
  	| < ELSE: "else">

	| < INT : "int" >
	| < CHAR : "char" >
	| < FLOAT : "float" >
	| < LONG : "long" >
  	
	| < PARAL: "(" > 
  	| < PARAR: ")" >
  	
	| < ACCOL: "{" > 
  	| < ACCOR: "}" >
  	
	| < EGAL: "=" > 
  	| < PVIRG: ";" >
	| < POINT: "." >
	| < NOT : "!" >
	
	| < TRUE: "true" >
	| < FALSE: "false" >
	
	
	| < PLUS: "+" >
	| < MINUS: "-" >
	| < MULT: "*" >
	| < DIV: "/" >
}



/** Tokens literaux */

TOKEN : {
	  < INTEGER: (["0"-"9"])+ >
	| < IDENT: (["a"-"z"] | ["A"-"Z"]) (["a"-"z"] | ["A"-"Z"] | ["0"-"9"] | "_")* >
}


/** Syntaxique rules **/
void Axiome()#void : {} {
	  Code()
	//AffichageLexeme()
}


/** Shows Lex√®mes **/
void AffichageLexeme() : {} {
	(
		( < IF> {System.out.print("Token IF = ");}
		| < THEN> {System.out.print("Token THEN = ");}
		| < PARAL> {System.out.print("Token PARAL = ");}
		| < PARAR> {System.out.print("Token PARAR = ");}
		| < ACCOL> {System.out.print("Token ACCOL = ");}
		| < ACCOR> {System.out.print("Token ACCOR = ");}
		| < EGAL> {System.out.print("Token EGAL = ");}
		| < PVIRG> {System.out.print("Token PVIRG = ");}
		| < ELSE> {System.out.print("Token ELSE = ");}
		| <FOR> {System.out.print("Token FOR = ");}
		| <PLUS> {System.out.print("Token PLUS = ");}
		| <MINUS> {System.out.print("Token MINUS = ");}
		| <MULT> {System.out.print("Token MULT = ");}
		| <DIV> {System.out.print("Token DIV = ");}
		| <IDENT> {System.out.print("Token IDENT = ");}
		| <INTEGER> {System.out.print("Token INTEGER = ");}
		| <MAIN> {System.out.println("Token MAIN = ");}
		) {System.out.println(token.image);}
	)+ 
	<EOF>
}


/** Syntaxique code rules **/

void Code() : {} {
	Instructions()
	<EOF> {System.out.println("Fin fichier.");}
}


void Instructions()#void : {} {
	(  	 Main()
		| Condition() 
		| Affectation()
		| For()
		
	)+	
}

void Main()#Main : {} {
	<MAIN> <PARAL> <PARAR> <ACCOR> <ACCOL>	
}

void Condition() : {} {
	<IF> <PARAL> Ident() <PARAR> <THEN> <ACCOL> Instructions() <ACCOR> [ <ELSE>  <ACCOL> Instructions() <ACCOR>]
}

void Affectation()#Affectation : {} {
	Ident() <EGAL> ExpressionArithmetique() <PVIRG>
}

void For() : {} {
	<FOR> <PARAL> Ident() <EGAL> ExpressionArithmetique() <PVIRG> Ident() <PVIRG> Ident() <PARAR> <ACCOL> Instructions() <ACCOR> 
	
}


/** Expressions Arithmetiques */

void ExpressionArithmetique() : {} {
	ProduitArithmetique() (   ( <PLUS> ExpressionArithmetique())
				| ( <MINUS> ExpressionArithmetique() ) )?

}

void ProduitArithmetique() : {} {
	Element() (   ( <MULT> ProduitArithmetique() ) 
		    | ( <DIV> ProduitArithmetique()  ))?
}

void Element() #void : {} {
	 Entier() | <IDENT> 
}

void Entier() : {
  int val1 = 1;
  int val = 0;
} {
  (<MINUS> { })?
  <INTEGER> {   }
}

/** Expressions Booleennes */

void ExpressionBooleenne() : {} {
	 Element() ( <EGAL><EGAL> (<TRUE>|<FALSE>) )? | <NOT>Element()
}


void Ident()  : {
	String val = "";
	} {
	<IDENT> {
	try {
		val = token.image;
	} catch (Exception e) {
		System.err.println("Not a string : " + token.image);
	}
	//jjtThis.setValeur(val);
	}
}
